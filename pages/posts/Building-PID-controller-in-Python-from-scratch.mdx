import Layout from '../../components/Layout';
import 'katex/dist/katex.min.css';
import { InlineMath, BlockMath } from 'react-katex';

export const meta = {
    title: 'Building a PID controller in Python from scratch',
    date: '2023-03-25'
}

When I was in the university, my control system classes was dictated using MATLAB,
MATLAB is a powerfull tool to design and test control systems. But, one of the
things that overwhelms me about Matlab, is that it is a very heavy program with 
different types of packages for different uses and a large number of tools and 
I like a simple minimalist coding style stuff for create or design stuff. 

As I am familiar with Python and its scientific libraries such as Scipy, Numpy, 
or Sympy, I became curious to utilize these tools to design a basic control 
system such as a PID controller, applying the theory I learned in university.

So here is what I learned.

## What is a PID controller?

A basic diagram of a PID controller looks like this:

![pid](/images/pid.drawio.svg)

e(t) is known as the error signal, which is the difference between a desired 
process value or setpoint r(t) and a measured process variable y(t) from the 
system that we want to control called "plant". u(t) is the output of the PID 
controller known as the control signal that will attempts to minimize the error 
e(t) over time. 

The PID controller, consists in 3 different parts: the Proportional part, 
the integral part and the derivative part.

The proportional part helps to maintain the desired output of the control 
system by working to reduce the difference between the desired output and the 
actual output of the system. For example, the cruise control that keeps you at 
the right speed when you're driving on a flat road. If you start going too slow, 
the proportional part tells the car to go a little faster so you get back to the 
right speed. If you start going too fast, it tells the car to go slower.

The integral part, keeps track of how much the system has been off from the 
desired output in the past and makes adjustments to help reduce that difference 
over time. It's like a person who remembers that they were too hot or too cold 
in a room yesterday and adjusts the thermostat today to make sure they're more 
comfortable.

The derivative part of a PID controller is like a watchdog that watches how 
things are changing over time. It looks for how fast things are changing and 
makes adjustments based on that. Imagine you're going downhill in your car and 
you start going faster, the derivative part of a cruise control system would 
sense this change in speed and make adjustments to slow you down.

Mathematly, in time domain the PID controller looks like this:

<div style={{ display: 'block', margin: 'auto', width: '60%' }}>
    <InlineMath math="u(t) = K_p e(t) + K_i \int_{0}^{t} e(\tau) d\tau + K_d \frac{d}{dt} e(t)"/>
</div>

Where:

* <InlineMath math="K_p"/>: represents how much the output of the controller 
changes in response to a difference between the desired output and the actual 
output of the system.

* <InlineMath math="k_i"/>: represents how much the output of the controller 
changes in response to the accumulated difference between the desired and actual
outputs of the system over time.

* <InlineMath math="k_d"/>: represents how much the output of the controller 
changes in response to the rate of change of the difference between the desired 
and actual outputs of the system.

* <InlineMath math="e(t)"/>: represents the error signal.

* <InlineMath math="u(t)"/>: represents control signal.

Next, we'll use Sympy and Numpy to design a PID controller and plot it using Matplotlib.

## Desiging the PID controller

First, we need a system to control before create our PID controller. We have two
ways for create the system also called "plant" in python, a symbolic approach
using sympy or a similar approach to MATLAB using scipy.

We can use this model system as example.

<div style={{display: 'block', margin: 'auto', width: '20%'}}>
    <InlineMath math="\frac{1}{s(s+1)(s+5)}"/>
</div>

You may be wondering why s?, it's because the Laplace domain. It is used instead
of time domain because it allows for analysis of the transfer functions of linear 
time-invariant systems(LTI) in a simpler and more efficient manner.

Using simpy, we can create our LTI system like this:

```python
# symbolic
s = sympy.symbols('s')
system = 1/(s*(s+1)*(s+5))
```

For create our LTI system, we need to know what are the poles and zeros of our 
system. We can expand our previous symbolic equation to get that.

```python
expanded_system = sympy.expand(system)

#result
1/(s**3 + 6*s**2 + 5*s)
```

Then we know that our poles are [1, 6, 5, 0], so now we can create our LTI system
like this.

```python
#scipy
num = [1]
den = [1, 6, 5, 0]
system = signal.lti(num,den)
```

## Testing the PID


## Reference


export default ({ children }) => <Layout meta={meta}>{children}</Layout>

